//Enums, ne sera pas dans SQLite mais à remplacer par CHECK(... in {...})
Enum mentions {
  TB
  B
  AB
  S
}

//Tables

Table etat_reponse{
  code integer [pk]
  etat text [not null]
}

Table ecole{
  code integer [pk]
  name text
}
Ref: candidat.etablissement > etablissement.rne

Table etablissement{
  rne text [pk, note: 'code etablissement']
  type text
  name text
  cp text [note: 'pas forcement que des chiffres']
  ville text
  pays text
}

Table concours {
  code integer [pk]
  lib text
  voie text
}

Ref: concours.code < candidat.voie_concours

Table voeux {
  candidat integer
  ordre integer
  ecole integer
  Indexes {
    (candidat, ecole) [pk]
    (candidat, ordre) [unique]
  }
}
Ref: ecole.code < voeux.ecole
Ref: candidat.code < voeux.candidat

Table candidat{
  code integer [pk]
  civilite text [note: 'ecrire un check pour M. et Mme']
  nom text
  prenom text
  date_de_naissance date [note: 'format 2000-12-31']
  classe text [note: 'ajouter un check']
  puissance text [note: 'ajouter check 3/2 5/2 7/2']
  voie_concours integer [note: 'la voie du concours']
  etablissement text
  adresse1 text
  adresse2 text [note: 'valeur par défaut vide']
  code_postal text [note: 'des chiffres et des lettres']
  commune text [note: 'commune du domicile']
  code_adr_pays integer
  mail text
  tel text [note: 'contient des +33 ou des ()']
  por text [note: 'contient des +33 ou des ()']
  code_pays_naissance integer [note: 'code du pays']
  code_pays_nationalite integer [note: 'code du pays']
  ville_ecrit text
  ine text [unique]
  csp_pere integer
  csp_mere integer
  
  //bac
  bac integer [ref: > serie_bac.code]
  annee_bac integer
  mois_bac integer
  mention_bac mentions [note: 'du text avec check( in {TB,B,AB,S})']
  dep_bac integer [note: 'departement du bac, peut être NULL (pas l info à chaque fois']
  
  dossier integer [ref: > etat_dossier.code]
  qualite text [note: 'check Boursier ou NULL']
  decla_handicap binary [note: 'oui ou non, non par defaut ?']
  arrondissement_naissance integer [note: '0 par defaut, c est quoi ?']

  // option peut etre null
  option1 integer [ref: > ep_option.id]
  option2 integer [ref: > ep_option.id]
  option3 integer [ref: > ep_option.id]
  option4 integer [ref: > ep_option.id]
  tipe text
}

Table classement {
  id integer [pk]
  etudiant integer
  rang integer [note: 'rang > 0']
  type text [note: 'rang sur les feuilles admis, admissible, etc.']
}
Ref: classement.etudiant > candidat.code

Table epreuve {
  id integer
  lib text
}

Table notes {
  candidat integer
  epreuve integer
  score integer
  Indexes{
    (candidat,epreuve) [pk]
  }
}
Ref: notes.candidat > candidat.code
Ref: notes.epreuve > epreuve.id

Table autres_prenoms {
  etudiant integer
  prenom text
  Indexes{
    (etudiant,prenom) [pk]
  }
}

Ref: autres_prenoms.etudiant > candidat.code

Table pays {
  code integer [pk, note: 'verifier les codes pays']
  lib text
}

Ref: pays.code < candidat.code_adr_pays
Ref: pays.code < candidat.code_pays_naissance
Ref: pays.code < candidat.code_pays_nationalite

Table csp_parent {
  code integer [pk, note: 'code associe a ces professions']
  lib text [unique, note: 'libelle des domaines de professions']
}

Ref: csp_parent.code < candidat.csp_pere
Ref: csp_parent.code < candidat.csp_mere

Table serie_bac {
  code integer [pk, note: 'code_serie du bac']
  lib text [unique]
}

Table etat_dossier {
  code integer [pk]
  lib text [unique]
}

Table ep_option {
  id integer [pk, note: 'couple unique epreuve et option']
  epreuve text
  option text
  Indexes {
    (epreuve,option) [unique]
  }
}
