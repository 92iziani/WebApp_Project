//Enums, ne sera pas dans SQLite mais à remplacer par CHECK(... in {...})
Enum mentions {
  TB
  B
  AB
  S
}

//Tables

Table etat_reponse{
  code integer [pk]
  etat text [not null]
}

Table ecole{
  code integer [pk]
  name text
}
Ref: candidat.etablissement > etablissement.rne

Table etablissement{
  rne text [pk, note: 'code etablissement']
  type text
  name text
  cp text [note: 'pas forcement que des chiffres']
  ville text
  pays text
}

Table concours {
  code integer [pk]
  lib text
  voie text
}

Ref: concours.code < candidat.voie_concours

Table voeux {
  candidat integer
  ordre integer
  ecole integer
  Indexes {
    (candidat, ecole) [pk]
    (candidat, ordre) [unique]
  }
}
Ref: ecole.code < voeux.ecole
Ref: candidat.code < voeux.candidat

Table candidat{
  code integer [pk]
  civilite text [note: 'ecrire un check pour M. et Mme']
  nom text
  prenom text
  date_de_naissance date [note: 'choisir un forma pour la date']
  classe text [note: 'classe origine, avec un check ?']
  puissance text [note: '3/2 5/2 7/2']
  voie_concours integer [note: 'la voie du concours']
  etablissement text
  adresse1 text
  adresse2 text [note: 'valeur par défaut vide']
  code_postal text [note: '5 chiffres en principe, il existe aussi en lettre ?']
  commune text [note: 'commune existante']
  code_adr_pays integer [note: 'existant ?']
  mail text [note: 'doit contenir @ et un .']
  tel integer [note: '10 chiffres ? avec préfixe ?']
  por integer [note: '10 chiffres ? avec préfixe ?']
  rang integer [note: 'unique ?']
  code_pays_naissance integer [note: 'code du pays']
  code_pays_nationalite integer [note: 'code du pays']
  ville_ecrit text
  ine text [note: 'unique ?']
  csp_pere integer
  csp_mere integer
  
  //bac
  bac integer [ref: > serie_bac.code]
  annee_bac integer
  mois_bac integer
  mention_bac mentions [note: 'du text avec check( in {TB,B,AB,S})']
  dep_bac integer [note: 'departement du bac, peut être NULL (pas l info à chaque fois']
  
  dossier integer [ref: > etat_dossier.code]
  qualite text [note: 'Boursier ou NULL']
  decla_handicap binary [note: 'oui ou non, non par defaut ?']
  arrondissement_naissance integer [note: 'mais qu est-ce que c est ? non par defaut ?']
  option1 integer [ref: > ep_option.id]
  option2 integer [ref: > ep_option.id]
  option3 integer [ref: > ep_option.id]
  option4 integer [ref: > ep_option.id]
  tipe text
}

Table classement {
  id integer [pk]
  etudiant integer
  rang integer
  type text
}
Ref: classement.etudiant > candidat.code

Table epreuve {
  id integer
  label text [note: 'matiere ou libelle de epreuve']
}

Table notes {
  candidat integer
  epreuve integer
  score integer
  Indexes{
    (candidat,epreuve) [pk]
  }
}
Ref: notes.candidat > candidat.code
Ref: notes.epreuve > epreuve.id

Table autres_prenoms {
  etudiant integer
  prenom text
  Indexes{
    (etudiant,prenom) [pk]
  }
}

Ref: autres_prenoms.etudiant > candidat.code

Table pays {
  code integer [pk, note: 'verifier les codes pays']
  lib text
}

Ref: pays.code < candidat.code_adr_pays
Ref: pays.code < candidat.code_pays_naissance
Ref: pays.code < candidat.code_pays_nationalite

Table csp_parent {
  cod integer [pk, note: 'code associe a ces professions']
  lib text [note: 'libelle des domaines de professions']
}

Ref: csp_parent.cod < candidat.csp_pere
Ref: csp_parent.cod < candidat.csp_mere

Table serie_bac {
  code integer [pk, note: 'code_serie du bac']
  lib text [note: 'unique ? avec un check plutot ?']
}

Table etat_dossier {
  code integer [pk]
  libelle text [note: 'unique ?']
}

Table ep_option {
  id integer [pk, note: 'couple unique epreuve et option']
  epreuve text
  option text
  Indexes {
    (epreuve,option) [unique]
  }
}
